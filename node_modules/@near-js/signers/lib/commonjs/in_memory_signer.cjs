"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var in_memory_signer_exports = {};
__export(in_memory_signer_exports, {
  InMemorySigner: () => InMemorySigner
});
module.exports = __toCommonJS(in_memory_signer_exports);
var import_crypto = require("@near-js/crypto");
var import_keystores = require("@near-js/keystores");
var import_sha256 = require("@noble/hashes/sha256");
class InMemorySigner {
  keyStore;
  constructor(keyStore) {
    this.keyStore = keyStore;
  }
  /**
   * Creates a single account Signer instance with account, network and keyPair provided.
   *
   * Intended to be useful for temporary keys (e.g. claiming a Linkdrop).
   *
   * @param networkId The targeted network. (ex. default, betanet, etc…)
   * @param accountId The NEAR account to assign the key pair to
   * @param keyPair The keyPair to use for signing
   */
  static async fromKeyPair(networkId, accountId, keyPair) {
    const keyStore = new import_keystores.InMemoryKeyStore();
    await keyStore.setKey(networkId, accountId, keyPair);
    return new InMemorySigner(keyStore);
  }
  /**
   * Creates a public key for the account given
   * @param accountId The NEAR account to assign a public key to
   * @param networkId The targeted network. (ex. default, betanet, etc…)
   * @returns {Promise<PublicKey>}
   */
  async createKey(accountId, networkId, keyType) {
    const keyPair = keyType === import_crypto.KeyType.SECP256K1 ? import_crypto.KeyPair.fromRandom("secp256k1") : import_crypto.KeyPair.fromRandom("ed25519");
    await this.keyStore.setKey(networkId, accountId, keyPair);
    return keyPair.getPublicKey();
  }
  /**
   * Gets the existing public key for a given account
   * @param accountId The NEAR account to assign a public key to
   * @param networkId The targeted network. (ex. default, betanet, etc…)
   * @returns {Promise<PublicKey>} Returns the public key or null if not found
   */
  async getPublicKey(accountId, networkId) {
    const keyPair = await this.keyStore.getKey(networkId, accountId);
    if (keyPair === null) {
      return null;
    }
    return keyPair.getPublicKey();
  }
  /**
   * @param message A message to be signed, typically a serialized transaction
   * @param accountId the NEAR account signing the message
   * @param networkId The targeted network. (ex. default, betanet, etc…)
   * @returns {Promise<Signature>}
   */
  async signMessage(message, accountId, networkId) {
    const hash = new Uint8Array((0, import_sha256.sha256)(message));
    if (!accountId) {
      throw new Error("InMemorySigner requires provided account id");
    }
    const keyPair = await this.keyStore.getKey(networkId, accountId);
    if (keyPair === null) {
      throw new Error(`Key for ${accountId} not found in ${networkId}`);
    }
    return keyPair.sign(hash);
  }
  toString() {
    return `InMemorySigner(${this.keyStore})`;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  InMemorySigner
});
