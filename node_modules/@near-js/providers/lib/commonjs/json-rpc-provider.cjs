"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var json_rpc_provider_exports = {};
__export(json_rpc_provider_exports, {
  JsonRpcProvider: () => JsonRpcProvider
});
module.exports = __toCommonJS(json_rpc_provider_exports);
var import_utils = require("@near-js/utils");
var import_types = require("@near-js/types");
var import_transactions = require("@near-js/transactions");
var import_fetch_json = require('./fetch_json.cjs');
const REQUEST_RETRY_NUMBER = 12;
const REQUEST_RETRY_WAIT = 500;
const REQUEST_RETRY_WAIT_BACKOFF = 1.5;
let _nextId = 123;
const DEFAULT_FINALITY = "optimistic";
class JsonRpcProvider {
  /** @hidden */
  connection;
  /** @hidden */
  options;
  /** @hidden */
  networkId;
  /**
   * @param connectionInfo Connection info
   */
  constructor(connectionInfo, options) {
    this.connection = connectionInfo || { url: "" };
    const defaultOptions = {
      retries: REQUEST_RETRY_NUMBER,
      wait: REQUEST_RETRY_WAIT,
      backoff: REQUEST_RETRY_WAIT_BACKOFF
    };
    this.options = Object.assign({}, defaultOptions, options);
    this.networkId = void 0;
  }
  async getNetworkId() {
    if (this.networkId) return this.networkId;
    const { chain_id } = await this.viewNodeStatus();
    this.networkId = chain_id;
    return this.networkId;
  }
  async getCurrentEpochSeatPrice() {
    const { minimum_stake_ratio: minStakeRatio, protocol_version: protocolVersion } = await this.experimental_protocolConfig({ finality: DEFAULT_FINALITY });
    const { current_validators: currentValidators } = await this.viewValidators();
    const maxNumberOfSeats = 300;
    return (0, import_utils.findSeatPrice)(currentValidators, maxNumberOfSeats, minStakeRatio, protocolVersion);
  }
  async getNextEpochSeatPrice() {
    const { minimum_stake_ratio: minStakeRatio, protocol_version: protocolVersion } = await this.experimental_protocolConfig({ finality: DEFAULT_FINALITY });
    const { next_validators: nextValidators } = await this.viewValidators();
    const maxNumberOfSeats = 300;
    return (0, import_utils.findSeatPrice)(nextValidators, maxNumberOfSeats, minStakeRatio, protocolVersion);
  }
  async viewAccessKey(accountId, publicKey, finalityQuery = { finality: DEFAULT_FINALITY }) {
    const data = await this.query({
      ...finalityQuery,
      request_type: "view_access_key",
      account_id: accountId,
      public_key: publicKey.toString()
    });
    return {
      ...data,
      nonce: BigInt(data.nonce)
    };
  }
  async viewAccessKeyList(accountId, finalityQuery = { finality: DEFAULT_FINALITY }) {
    return this.query({
      ...finalityQuery,
      request_type: "view_access_key_list",
      account_id: accountId
    });
  }
  async viewAccount(accountId, blockQuery = { finality: DEFAULT_FINALITY }) {
    const data = await this.query({
      ...blockQuery,
      request_type: "view_account",
      account_id: accountId
    });
    return {
      ...data,
      amount: BigInt(data.amount),
      locked: BigInt(data.locked)
    };
  }
  async viewContractCode(contractId, blockQuery = { finality: DEFAULT_FINALITY }) {
    const data = await this.query({
      ...blockQuery,
      request_type: "view_code",
      account_id: contractId
    });
    return {
      ...data,
      code: new Uint8Array(Buffer.from(data.code_base64, "base64"))
    };
  }
  async viewContractState(contractId, prefix, blockQuery = { finality: DEFAULT_FINALITY }) {
    const prefixBase64 = Buffer.from(prefix || "").toString("base64");
    return this.query({
      ...blockQuery,
      request_type: "view_state",
      account_id: contractId,
      prefix_base64: prefixBase64
    });
  }
  async callFunction(contractId, method, args, blockQuery = { finality: DEFAULT_FINALITY }) {
    const { result } = await this.callFunctionRaw(
      contractId,
      method,
      args,
      blockQuery
    );
    if (result.length === 0) return void 0;
    const serializedResult = Buffer.from(result).toString();
    try {
      return JSON.parse(serializedResult);
    } catch {
      return serializedResult;
    }
  }
  async callFunctionRaw(contractId, method, args, blockQuery = { finality: DEFAULT_FINALITY }) {
    const argsBuffer = ArrayBuffer.isView(args) ? Buffer.from(args) : Buffer.from(JSON.stringify(args));
    const argsBase64 = argsBuffer.toString("base64");
    return await this.query({
      ...blockQuery,
      request_type: "call_function",
      account_id: contractId,
      method_name: method,
      args_base64: argsBase64
    });
  }
  async viewBlock(blockQuery) {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("block", { block_id: blockId, finality });
  }
  async viewChunk(chunkId) {
    return this.sendJsonRpc("chunk", [chunkId]);
  }
  async viewGasPrice(blockId) {
    return this.sendJsonRpc("gas_price", [blockId || null]);
  }
  async viewNodeStatus() {
    return this.sendJsonRpc("status", []);
  }
  async viewValidators(blockId) {
    return this.sendJsonRpc("validators", [blockId || null]);
  }
  /**
   * Query validators of an epoch.
   * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
   *
   * @param params Object specifying either a block or epoch to query.
   * - `{ blockId }`: Block hash or height.
   * - `{ epochId }`: Epoch hash.
   * - `null`: Current epoch.
   */
  async viewValidatorsV2(params) {
    if (params === null) return this.sendJsonRpc("validators", [null]);
    if (typeof params === "object" && "blockId" in params) return this.sendJsonRpc("validators", { block_id: params.blockId });
    if (typeof params === "object" && "epochId" in params) return this.sendJsonRpc("validators", { epoch_id: params.epochId });
    throw new Error("Invalid parameters for validatorsV2");
  }
  async viewTransactionStatus(txHash, accountId, waitUntil) {
    const encodedTxHash = typeof txHash === "string" ? txHash : (0, import_utils.baseEncode)(txHash);
    return this.sendJsonRpc("tx", {
      tx_hash: encodedTxHash,
      sender_account_id: accountId,
      wait_until: waitUntil
    });
  }
  async viewTransactionStatusWithReceipts(txHash, accountId, waitUntil) {
    const encodedTxHash = typeof txHash === "string" ? txHash : (0, import_utils.baseEncode)(txHash);
    return this.sendJsonRpc("EXPERIMENTAL_tx_status", {
      tx_hash: encodedTxHash,
      sender_account_id: accountId,
      wait_until: waitUntil
    });
  }
  async viewTransactionReceipt(receiptId) {
    return this.sendJsonRpc("EXPERIMENTAL_receipt", {
      receipt_id: receiptId
    });
  }
  /**
   * Gets the RPC's status
   * @see [https://docs.near.org/docs/develop/front-end/rpc#general-validator-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
   */
  async status() {
    return this.sendJsonRpc("status", []);
  }
  /**
   * Sends a signed transaction to the RPC
   *
   * @param signedTransaction The signed transaction being sent
   * @param waitUntil
   */
  async sendTransactionUntil(signedTransaction, waitUntil) {
    const bytes = (0, import_transactions.encodeTransaction)(signedTransaction);
    return this.sendJsonRpc("send_tx", { signed_tx_base64: Buffer.from(bytes).toString("base64"), wait_until: waitUntil });
  }
  /**
   * Sends a signed transaction to the RPC and waits until transaction is fully complete
   * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
   *
   * @param signedTransaction The signed transaction being sent
   */
  async sendTransaction(signedTransaction) {
    return this.sendTransactionUntil(signedTransaction, "EXECUTED_OPTIMISTIC");
  }
  /**
   * Sends a signed transaction to the RPC and immediately returns transaction hash
   * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
   * @param signedTransaction The signed transaction being sent
   * @returns {Promise<FinalExecutionOutcome>}
   */
  async sendTransactionAsync(signedTransaction) {
    return this.sendTransactionUntil(signedTransaction, "NONE");
  }
  /**
   * Gets a transaction's status from the RPC
   * @see [https://docs.near.org/docs/develop/front-end/rpc#transaction-status](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
   *
   * @param txHash A transaction hash as either a Uint8Array or a base58 encoded string
   * @param accountId The NEAR account that signed the transaction
   * @param waitUntil
   */
  async txStatus(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
    if (typeof txHash === "string") {
      return this.txStatusString(txHash, accountId, waitUntil);
    } else {
      return this.txStatusUint8Array(txHash, accountId, waitUntil);
    }
  }
  async txStatusUint8Array(txHash, accountId, waitUntil) {
    return this.sendJsonRpc("tx", { tx_hash: (0, import_utils.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
  }
  async txStatusString(txHash, accountId, waitUntil) {
    return this.sendJsonRpc("tx", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
  }
  /**
   * Gets a transaction's status from the RPC with receipts
   * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#transaction-status-with-receipts)
   * @param txHash The hash of the transaction
   * @param accountId The NEAR account that signed the transaction
   * @param waitUntil
   * @returns {Promise<FinalExecutionOutcome>}
   */
  async txStatusReceipts(txHash, accountId, waitUntil = "EXECUTED_OPTIMISTIC") {
    if (typeof txHash === "string") {
      return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: txHash, sender_account_id: accountId, wait_until: waitUntil });
    } else {
      return this.sendJsonRpc("EXPERIMENTAL_tx_status", { tx_hash: (0, import_utils.baseEncode)(txHash), sender_account_id: accountId, wait_until: waitUntil });
    }
  }
  /**
   * Query the RPC by passing an {@link "@near-js/types".provider/request.RpcQueryRequest | RpcQueryRequest }
   * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
   *
   * @typeParam T the shape of the returned query response
   */
  async query(...args) {
    let result;
    if (args.length === 1) {
      const { block_id, blockId, ...otherParams } = args[0];
      result = await this.sendJsonRpc("query", { ...otherParams, block_id: block_id || blockId });
    } else {
      const [path, data] = args;
      result = await this.sendJsonRpc("query", [path, data]);
    }
    if (result && result.error) {
      throw new import_types.TypedError(
        `Querying failed: ${result.error}.
${JSON.stringify(result, null, 2)}`,
        (0, import_utils.getErrorTypeFromErrorMessage)(result.error, result.error.name)
      );
    }
    return result;
  }
  /**
   * Query for block info from the RPC
   * pass block_id OR finality as blockQuery, not both
   * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
   *
   * @param blockQuery {@link BlockReference} (passing a {@link BlockId} is deprecated)
   */
  async block(blockQuery) {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("block", { block_id: blockId, finality });
  }
  /**
   * Query changes in block from the RPC
   * pass block_id OR finality as blockQuery, not both
   * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
   */
  async blockChanges(blockQuery) {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("EXPERIMENTAL_changes_in_block", { block_id: blockId, finality });
  }
  /**
   * Queries for details about a specific chunk appending details of receipts and transactions to the same chunk data provided by a block
   * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
   *
   * @param chunkId Hash of a chunk ID or shard ID
   */
  async chunk(chunkId) {
    return this.sendJsonRpc("chunk", [chunkId]);
  }
  /**
   * Query validators of the epoch defined by the given block id.
   * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
   *
   * @param blockId Block hash or height, or null for latest.
   */
  async validators(blockId) {
    return this.sendJsonRpc("validators", [blockId]);
  }
  /**
   * Gets the protocol config at a block from RPC
   *
   * @param blockReference specifies the block to get the protocol config for
   */
  async experimental_protocolConfig(blockReference) {
    const { blockId, ...otherParams } = blockReference;
    return await this.sendJsonRpc("EXPERIMENTAL_protocol_config", { ...otherParams, block_id: blockId });
  }
  /**
   * Gets a light client execution proof for verifying execution outcomes
   * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
   */
  async lightClientProof(request) {
    return await this.sendJsonRpc("EXPERIMENTAL_light_client_proof", request);
  }
  /**
   * Returns the next light client block as far in the future as possible from the last known hash
   * to still be able to validate from that hash. This will either return the last block of the
   * next epoch, or the last final known block.
   * 
   * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
   */
  async nextLightClientBlock(request) {
    return await this.sendJsonRpc("next_light_client_block", request);
  }
  /**
   * Gets access key changes for a given array of accountIds
   * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
   * @returns {Promise<ChangeResult>}
   */
  async accessKeyChanges(accountIdArray, blockQuery) {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("EXPERIMENTAL_changes", {
      changes_type: "all_access_key_changes",
      account_ids: accountIdArray,
      block_id: blockId,
      finality
    });
  }
  /**
   * Gets single access key changes for a given array of access keys
   * pass block_id OR finality as blockQuery, not both
   * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
   * @returns {Promise<ChangeResult>}
   */
  async singleAccessKeyChanges(accessKeyArray, blockQuery) {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("EXPERIMENTAL_changes", {
      changes_type: "single_access_key_changes",
      keys: accessKeyArray,
      block_id: blockId,
      finality
    });
  }
  /**
   * Gets account changes for a given array of accountIds
   * pass block_id OR finality as blockQuery, not both
   * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
   * @returns {Promise<ChangeResult>}
   */
  async accountChanges(accountIdArray, blockQuery) {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("EXPERIMENTAL_changes", {
      changes_type: "account_changes",
      account_ids: accountIdArray,
      block_id: blockId,
      finality
    });
  }
  /**
   * Gets contract state changes for a given array of accountIds
   * pass block_id OR finality as blockQuery, not both
   * Note: If you pass a keyPrefix it must be base64 encoded
   * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
   * @returns {Promise<ChangeResult>}
   */
  async contractStateChanges(accountIdArray, blockQuery, keyPrefix = "") {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("EXPERIMENTAL_changes", {
      changes_type: "data_changes",
      account_ids: accountIdArray,
      key_prefix_base64: keyPrefix,
      block_id: blockId,
      finality
    });
  }
  /**
   * Gets contract code changes for a given array of accountIds
   * pass block_id OR finality as blockQuery, not both
   * Note: Change is returned in a base64 encoded WASM file
   * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
   * @returns {Promise<ChangeResult>}
   */
  async contractCodeChanges(accountIdArray, blockQuery) {
    const { finality } = blockQuery;
    const { blockId } = blockQuery;
    return this.sendJsonRpc("EXPERIMENTAL_changes", {
      changes_type: "contract_code_changes",
      account_ids: accountIdArray,
      block_id: blockId,
      finality
    });
  }
  /**
   * Returns gas price for a specific block_height or block_hash.
   * @see [https://docs.near.org/api/rpc/gas](https://docs.near.org/api/rpc/gas)
   *
   * @param blockId Block hash or height, or null for latest.
   */
  async gasPrice(blockId) {
    return await this.sendJsonRpc("gas_price", [blockId]);
  }
  /**
   * Directly call the RPC specifying the method and params
   *
   * @param method RPC method
   * @param params Parameters to the method
   */
  async sendJsonRpc(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    const response = await (0, import_fetch_json.fetchJsonRpc)(this.connection.url, request, this.connection.headers || {}, (0, import_fetch_json.retryConfig)(this.options.retries, this.options.backoff, this.options.wait));
    if (response.error) {
      if (typeof response.error.data === "object") {
        if (typeof response.error.data.error_message === "string" && typeof response.error.data.error_type === "string") {
          throw new import_types.TypedError(response.error.data.error_message, response.error.data.error_type);
        }
        throw (0, import_utils.parseRpcError)(response.error.data);
      } else {
        const errorMessage = `[${response.error.code}] ${response.error.message}: ${response.error.data}`;
        const errorType = (0, import_utils.getErrorTypeFromErrorMessage)(response.error.data, "");
        if (errorType) {
          throw new import_types.TypedError((0, import_utils.formatError)(errorType, params), errorType);
        }
        throw new import_types.TypedError(errorMessage, response.error.name);
      }
    } else if (typeof response.result?.error === "string") {
      const errorType = (0, import_utils.getErrorTypeFromErrorMessage)(response.result.error, "");
      if (errorType) {
        throw new import_utils.ServerError((0, import_utils.formatError)(errorType, params), errorType);
      }
    }
    const { result } = response;
    if (typeof result === "undefined") {
      throw new import_types.TypedError(
        `Exceeded ${this.options.retries} attempts for request to ${method}.`,
        "RetriesExceeded"
      );
    }
    return result;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  JsonRpcProvider
});
